/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/filinvadim,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package cidlink

import (
	"bytes"
	"fmt"
	"io"
	"os"

	"github.com/ipld/go-ipld-prime/datamodel"
	"github.com/ipld/go-ipld-prime/linking"
)

// Memory is a simple in-memory storage for cidlinks. It's the same as `storage.Memory`
// but uses typical multihash semantics used when reading/writing cidlinks.
//
// Using multihash as the storage key rather than the whole CID will remove the
// distinction between CIDv0 and their CIDv1 counterpart. It also removes the
// distinction between CIDs where the multihash is the same but the codec is
// different, e.g. `dag-cbor` and a `raw` version of the same data.
type Memory struct {
	Bag map[string][]byte
}

func (store *Memory) beInitialized() {
	if store.Bag != nil {
		return
	}
	store.Bag = make(map[string][]byte)
}

func (store *Memory) OpenRead(lnkCtx linking.LinkContext, lnk datamodel.Link) (io.Reader, error) {
	store.beInitialized()
	cl, ok := lnk.(Link)
	if !ok {
		return nil, fmt.Errorf("incompatible link type: %T", lnk)
	}
	data, exists := store.Bag[string(cl.Hash())]
	if !exists {
		return nil, os.ErrNotExist
	}
	return bytes.NewReader(data), nil
}

func (store *Memory) OpenWrite(lnkCtx linking.LinkContext) (io.Writer, linking.BlockWriteCommitter, error) {
	store.beInitialized()
	buf := bytes.Buffer{}
	return &buf, func(lnk datamodel.Link) error {
		cl, ok := lnk.(Link)
		if !ok {
			return fmt.Errorf("incompatible link type: %T", lnk)
		}

		store.Bag[string(cl.Hash())] = buf.Bytes()
		return nil
	}, nil
}
