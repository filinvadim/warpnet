/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/filinvadim,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package danger

import (
	"fmt"
	"reflect"
	"unsafe"
)

const maxInt = uintptr(int(^uint(0) >> 1))

func SubsliceOffset(data []byte, subslice []byte) int {
	datap := (*reflect.SliceHeader)(unsafe.Pointer(&data))
	hlp := (*reflect.SliceHeader)(unsafe.Pointer(&subslice))

	if hlp.Data < datap.Data {
		panic(fmt.Errorf("subslice address (%d) is before data address (%d)", hlp.Data, datap.Data))
	}
	offset := hlp.Data - datap.Data

	if offset > maxInt {
		panic(fmt.Errorf("slice offset larger than int (%d)", offset))
	}

	intoffset := int(offset)

	if intoffset > datap.Len {
		panic(fmt.Errorf("slice offset (%d) is farther than data length (%d)", intoffset, datap.Len))
	}

	if intoffset+hlp.Len > datap.Len {
		panic(fmt.Errorf("slice ends (%d+%d) is farther than data length (%d)", intoffset, hlp.Len, datap.Len))
	}

	return intoffset
}

func BytesRange(start []byte, end []byte) []byte {
	if start == nil || end == nil {
		panic("cannot call BytesRange with nil")
	}
	startp := (*reflect.SliceHeader)(unsafe.Pointer(&start))
	endp := (*reflect.SliceHeader)(unsafe.Pointer(&end))

	if startp.Data > endp.Data {
		panic(fmt.Errorf("start pointer address (%d) is after end pointer address (%d)", startp.Data, endp.Data))
	}

	l := startp.Len
	endLen := int(endp.Data-startp.Data) + endp.Len
	if endLen > l {
		l = endLen
	}

	if l > startp.Cap {
		panic(fmt.Errorf("range length is larger than capacity"))
	}

	return start[:l]
}

func Stride(ptr unsafe.Pointer, size uintptr, offset int) unsafe.Pointer {
	// TODO: replace with unsafe.Add when Go 1.17 is released
	//   https://github.com/golang/go/issues/40481
	return unsafe.Pointer(uintptr(ptr) + uintptr(int(size)*offset))
}
