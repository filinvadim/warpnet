/* License generated by licensor(https://github.com/Marvin9/licensor).

 Warpnet - Decentralized Social Network
 Copyright (C) 2025 Vadim Filin, https://github.com/filinvadim,
 <github.com.mecdy@passmail.net>
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

package atlas

import "reflect"

type StructMap struct {
	// A slice of descriptions of each field in the type.
	// Each entry specifies the name by which each field should be referenced
	// when serialized, and defines a way to get an address to the field.
	Fields []StructMapEntry
}

type StructMapEntry struct {
	// The field name; will be emitted as token during marshal, and used for
	// lookup during unmarshal.  Required.
	SerialName string

	// If true, a key token with this SerialName will be ignored during unmarshal.
	// (By default, if there's no StructMapEntry for a key token, it's an error.)
	// If true, the ReflectRoute, Type, etc fields are irrelevant and may be nil.
	Ignore bool

	ReflectRoute ReflectRoute // reflection generates these.
	Type         reflect.Type // type to expect on the far side of the ReflectRoute.
	tagged       bool         // used during autogen.

	// Theoretical feature which would be alternative to ReflectRoute.  Support dropped for the moment.
	//addrFunc     func(interface{}) interface{} // custom user function.

	// If true, marshalling will skip this field if it's the zero value.
	OmitEmpty bool
}

type ReflectRoute []int

func (rr ReflectRoute) TraverseToValue(v reflect.Value) reflect.Value {
	for _, i := range rr {
		if v.Kind() == reflect.Ptr {
			if v.IsNil() {
				return reflect.Value{}
			}
			v = v.Elem()
		}
		v = v.Field(i)
	}
	return v
}
