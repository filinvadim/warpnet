// Package dto provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package dto

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	externalRef0 "github.com/filinvadim/warpnet/gen/domain-gen"
	"github.com/getkin/kin-openapi/openapi3"
)

// ChatsResponse defines model for ChatsResponse.
type ChatsResponse struct {
	Chats  []externalRef0.Chat `json:"chats"`
	Cursor string              `json:"cursor"`
	UserId *string             `json:"user_id,omitempty"`
}

// CreateChatRequest defines model for CreateChatRequest.
type CreateChatRequest struct {
	FromUserId string `json:"from_user_id"`
	ToUserId   string `json:"to_user_id"`
}

// FollowRequest defines model for FollowRequest.
type FollowRequest struct {
	ReaderId string `json:"reader_id"`
	WriterId string `json:"writer_id"`
}

// MessagesResponse defines model for MessagesResponse.
type MessagesResponse struct {
	ChatId   *string                    `json:"chat_id,omitempty"`
	Cursor   string                     `json:"cursor"`
	Messages []externalRef0.ChatMessage `json:"messages"`
	UserId   *string                    `json:"user_id,omitempty"`
}

// RepliesTreeResponse defines model for RepliesTreeResponse.
type RepliesTreeResponse struct {
	Cursor  string                   `json:"cursor"`
	Replies []externalRef0.ReplyNode `json:"replies"`
	UserId  *string                  `json:"user_id,omitempty"`
}

// TweetsResponse defines model for TweetsResponse.
type TweetsResponse struct {
	Cursor string               `json:"cursor"`
	Tweets []externalRef0.Tweet `json:"tweets"`
	UserId *string              `json:"user_id,omitempty"`
}

// UnfollowRequest defines model for UnfollowRequest.
type UnfollowRequest struct {
	ReaderId string `json:"reader_id"`
	WriterId string `json:"writer_id"`
}

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Cursor string              `json:"cursor"`
	Users  []externalRef0.User `json:"users"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9RWTW/bOBD9KwZ3j8oXdrEHXwPsKc0hcNBDUQi0OLJZSyQzpGoYgf97MZRk64OyJSFF",
	"25tsijNv3nt81DtLdG60AuUsW74zm2wh5/7xccudfQFrtLJAfxjUBtBJ8MsJLdODdJD7h78RUrZkf92d",
	"S95V9e6EzrlUMdVkx4i5gwG2ZByRH+h3UqDVSEWqFetQqg0tFRYwliKwdowYwlshEQRbfqlrRBWyr6cu",
	"ev0NEt/2EYE7IBAv8FaAdf2xUtR53OiZS/UEauO2bPkQ9dE5PfrlDtxWo1ahEPL/dZbp/SBqBC7GQt6j",
	"dLMQn5s0i4TQfgJr+QauuCes6kUz5FXhOb6rQIXsN91jJyCh8V/AZBLsCgEuMDA8JZb7pw5JbQ/PWnzQ",
	"iDWK0ISrPcDFcBgezvmtU2fzDT9mrgpAaKxXlf5R5+zVAs5TgWibLAK162swxHPZIgS7eRn0QfuMFnG5",
	"lmrM6YkJ7uDGyRxYgOpuaPdeGPi7nd59koyYCKXDhZdwOOij5rCtdldYq6NsWqxq5UC5Ec6dI8EQhaNv",
	"UnpT8Ryun+QGfdW4Ucl0PWGjWGuYC6w+yV2ATh8V4+HPOOsNX9S9LqA8J3xAeZkJBPWhlwZdAYdpCd3L",
	"MqoQneFdnM5z8PvLsArD/CUHLJO76V8K3u0BvX2xONGFagOTyv33L331SCXzImfL+9NeqRxsymvBcAQ1",
	"GD8I827+2hVBe5YlZyNGrQfx/tzk6uTVmbozqBkp5i/oni/XEt2WvDXebHMMKsAmKI2TWgUJLT+tQLQM",
	"0L+SOxrXu2JFKgYU7qtabel834zthHZCq8FDqXatCgVmIcoynfBBvvJDjJACIs8mTqK0gOFjSCVBxOvD",
	"oO1rM09JUG/YpgVa9q0RdfTskt4wSVPGK/YnKFKlmiC3TMgeT6mySDUu+EJIgr8uHIjFai+dA7yh0Ftw",
	"YzJZiRExJ11GHT5zNItncHuNOxax74C2LPxwe397T3RpA4obyZbsH/8XHWW3JZmOxx8BAAD///fpKURc",
	"EQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "./domain.yml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
